{
  "name": "upnode",
  "description": "transactional connection queue for dnode",
  "version": "0.4.3",
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/upnode.git"
  },
  "main": "index.js",
  "keywords": [
    "dnode",
    "queue",
    "message",
    "reconnect",
    "transaction",
    "interruption"
  ],
  "directories": {
    "example": "example",
    "test": "test"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "dependencies": {
    "dnode": "~1.0.1"
  },
  "devDependencies": {
    "tap": "~0.2.6"
  },
  "engines": {
    "node": ">=0.4.0"
  },
  "license": "MIT",
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "readme": "# upnode\n\nKeep a dnode connection alive and re-establish state between reconnects\nwith a transactional message queue.\n\n[![build status](https://secure.travis-ci.org/substack/upnode.png)](http://travis-ci.org/substack/upnode)\n\n# examples\n\n## simple service interruption\n\nserver.js:\n\n``` js\nvar upnode = require('upnode');\n\nvar server = upnode(function (client, conn) {\n    this.time = function (cb) { cb(new Date().toString()) };\n});\nserver.listen(7000);\n```\n\nNow when you want to make a call to the server, guard your connection in the\n`up()` function. If the connection is alive the callback fires immediately.\nIf the connection is down the callback is buffered and fires when the connection\nis ready again.\n\nclient.js:\n\n``` js\nvar upnode = require('upnode');\nvar up = upnode.connect(7000);\n\nsetInterval(function () {\n    up(function (remote) {\n        remote.time(function (t) {\n            console.log('time = ' + t);\n        });\n    });\n}, 1000);\n```\n\nIf we fire the client up first, then wait a few seconds to fire up the server:\n\n```\n$ node client.js & sleep 5; node server.js\n[1] 9165\ntime = Fri Dec 16 2011 23:47:48 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:48 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:48 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:48 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:48 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:49 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:50 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:51 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:52 GMT-0800 (PST)\n```\n\nwe can see that the first 5 seconds worth of requests are buffered and all come\nthrough at `23:47:48`. The requests then come in one per second once the\nconnection has been established.\n\nIf we kill the server and bring it back again while the client is running we can\nobserve a similar discontinuity as all the pending requests come through at `23:50:20`:\n\n```\n$ node client.js \ntime = Fri Dec 16 2011 23:50:11 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:11 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:12 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:13 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:21 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:22 GMT-0800 (PST)\n```\n\n## authenticated interruption\n\nOftentimes you'll want to re-establish state between reconnection attempts.\n\nSuppose we have a simple dnode server with a `beep` function protected behind an\n`auth` function:\n\nserver.js:\n\n``` js\nvar upnode = require('upnode');\n\nvar server = upnode(function (client, conn) {\n    this.auth = function (user, pass, cb) {\n        if (user === 'moo' && pass === 'hax') {\n            cb(null, {\n                beep : function (fn) { fn('boop at ' + new Date) }\n            });\n        }\n        else cb('ACCESS DENIED')\n    };\n});\nserver.listen(7000);\n```\n\nNow instead of doing `remote.auth()` every time the connection drops, we can\npass in a callback to `upnode.connect()` that will handle the re-authentication\nand expose the authenticated object to the `up()` transaction:\n\nclient.js:\n\n``` js\nvar upnode = require('upnode');\nvar up = upnode.connect(7000, function (remote, conn) {\n    remote.auth('moo', 'hax', function (err, res) {\n        if (err) console.error(err)\n        else conn.emit('up', res)\n    });\n});\n\nsetInterval(function () {\n    up(function (remote) {\n        remote.beep(function (s) {\n            console.log(s);\n        });\n    });\n}, 1000);\n```\n\nNow spin up the client.js and the server.js:\n\n```\n$ node client.js & sleep 2; node server.js\n[1] 10892\nboop at Sat Dec 17 2011 01:30:15 GMT-0800 (PST)\nboop at Sat Dec 17 2011 01:30:15 GMT-0800 (PST)\nboop at Sat Dec 17 2011 01:30:16 GMT-0800 (PST)\nboop at Sat Dec 17 2011 01:30:17 GMT-0800 (PST)\nboop at Sat Dec 17 2011 01:30:18 GMT-0800 (PST)\n```\n\nKill the server a few times and observe that the client re-authenticates between\nreconnects.\n\nYou could do any other sort of stateful operation here besides authentication.\nJust emit the object you want to expose to `up()` through\n`conn.emit('up', obj)`.\n\n## ssl stream example\n\nThis is very similar to the first example, except using tls streams. You can use\nany kind of full-duplex stream here, not just ssl.\n\nserver.js:\n\n``` js\nvar upnode = require('upnode');\nvar fs = require('fs');\nvar tls = require('tls');\n\nvar opts = {\n    key : fs.readFileSync(__dirname + '/keys/key.pem'),\n    cert : fs.readFileSync(__dirname + '/keys/cert.pem'),\n};\nvar server = tls.createServer(opts, function (stream) {\n    var up = upnode(function (client, conn) {\n        this.time = function (cb) { cb(new Date().toString()) };\n    });\n    up.pipe(stream).pipe(up);\n});\nserver.listen(7000);\n```\n\nclient.js:\n\n``` js\nvar upnode = require('upnode');\nvar tls = require('tls');\nvar up = upnode.connect({\n    createStream : tls.connect.bind(null, 7000)\n});\n\nsetInterval(function () {\n    up(function (remote) {\n        remote.time(function (t) {\n            console.log('time = ' + t);\n        });\n    });\n}, 1000);\n```\n\nIt behaves just like the first example when run on the command line, except that\nour connections go over ssl now:\n\n```\n$ node client.js & sleep 5; node server.js\n[1] 9178\ntime = Sun Jul 29 2012 02:31:00 GMT-0700 (PDT)\ntime = Sun Jul 29 2012 02:31:00 GMT-0700 (PDT)\ntime = Sun Jul 29 2012 02:31:00 GMT-0700 (PDT)\ntime = Sun Jul 29 2012 02:31:00 GMT-0700 (PDT)\ntime = Sun Jul 29 2012 02:31:00 GMT-0700 (PDT)\ntime = Sun Jul 29 2012 02:31:01 GMT-0700 (PDT)\ntime = Sun Jul 29 2012 02:31:02 GMT-0700 (PDT)\ntime = Sun Jul 29 2012 02:31:03 GMT-0700 (PDT)\n```\n\n# methods\n\n``` js\nvar upnode = require('upnode')\n```\n\n## var up = upnode(cons)\n\nCreate an upnode object `up` from the dnode constructor `cons`.\n\n`up` is a pipe-able object, which is a useful property when writing custom\nservers like in the ssl example.\n\nIn both server and client mode each side will send periodic heartbeats to the\nother side and sever the connection if data isn't getting through. Clients\ncreated with `up.connect()` will attempt to reconnect continuously.\n\n# up.listen(...)\n\nListen on a port with `net.createServer()`.\n\nTo use something other than `net.createServer()`, exploit how `up` is a\nfull-duplex stream that you can pipe data into and out of.\n\nReturns the net server object.\n\n## var cup = up.connect(...)\n\nEstablish an upnode connection with `net.connect()`.\n\nPass in dnode-style arguments where port, host, path, and options objects are\ninferred by the types of the arguments.\n\nReturns a transaction function `up()` for the connection.\n\nYou can use other streams besides `net.connect()` streams by passing in a\n`{ createStream : createStream }` object where `createStream()` is a function\nthat returns a new stream object. The connection will call `createStream()` when\nthe heartbeat fails or the previous stream ended or had errors.\n\nThe `cup` object emits `\"up\"` when the link is established, `\"down\" when the link\nis severed, and `\"reconnect\"` for each reconnection attempt.\n\nIf you give `.connect()` a callback, you *must* emit an `'up', remote` event on\nthe `conn` object with the remote object you want to make available to the\nsubsequent `up()` transactions.\n\nIf you don't pass a callback to `.connect()` this default callback is used:\n\n``` js\nfunction (remote, conn) {\n    conn.emit('up', remote);\n}\n```\n\nThe `conn` is just the dnode object.\n\nThe callback must emit an `'up'` event so that state can be rebuilt between\nconnection interruptions. A great use for this behavior is authentication where\ncertain functionality is only made available through the callback to a\n`.auth(username, password, cb)` function on the remote. For that case you could\nwrite a connection callback that looks like:\n\n``` js\nfunction (remote, conn) {\n    remote.auth(user, pass, function (err, obj) {\n        if (err) console.error(err)\n        else conn.emit('up', obj)\n    });\n}\n```\n\nand your dnode sessions will be re-authenticated between reconnects. The remote\nobject handle in `up()` will be the `obj` result provided by the `auth()`\ncallback.\n\nBesides being passed directly to dnode's `.connect(...)`, these additional\noption-object arguments are respected:\n\n* ping - Interval in milliseconds to send pings to the remote server.\n    Default 10000. Set to 0 to disable pings.\n* timeout - Time in milliseconds to wait for a ping response before triggering a\n    reconnect. Default 5000.\n* reconnect - Time in milliseconds to wait between reconnection attempts.\n    Default 1000.\n* createStream - Connection function to use instead of `net.connect()`.\n\n## var cup = upnode.connect(...)\n\nShortcut for `upnode({}).connect(...)` like how `dnode.connect(...)` is a\nshortcut for `dnode({}).connect(...)`.\n\n## cup(timeout=0, cb)\n\nCreate a new transaction from the callback `cb`.\n\nIf the connection is ready, `cb(remote, conn)` will fire immediately.\nOtherwise `cb` will be queued until the connection is available again.\n\nIf `timeout` is specified, fire `cb()` after `timeout` milliseconds with no\narguments. Here's an example of using timeouts:\n\n``` js\nup(5000, function (remote) {\n    if (!remote) console.error('resource timed out')\n    else remote.beep()\n})\n```\n\n## cup.close()\n\nClose the connection and don't attempt to reconnect.\n\n# install\n\nWith [npm](http://npmjs.org) do:\n\n```\nnpm install upnode\n```\n\n# license\n\nMIT\n",
  "readmeFilename": "README.markdown",
  "bugs": {
    "url": "https://github.com/substack/upnode/issues"
  },
  "_id": "upnode@0.4.3",
  "_from": "upnode@*"
}
